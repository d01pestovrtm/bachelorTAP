"""
Utils to obtain wirtinger presentation from a give knot diagram
"""


def wirt_presentation(strands):
    """Creates a dictionary representing Wirtinger presentation of a knot.

    Each key is identiefied to the relation generated by the strands crossing.
    Each value is a pair of integers:
        first value is +1 or -1 representing positive/negative relation
        second value is the id of overcrossed strand
    See ReadMe for the enumeration convention.

    Keyword arguments:
    strands -- the array of polylines representing knot strands
    """
    Wirt_dict = {i : None for i in range(0, len(strands))}
    for strand_index in range(0, len(strands)):
        find_crossed_strand(strand_index, strands, Wirt_dict)
    return Wirt_dict


#Colinerity TODO
def is_intersection(first_segment, second_segment):
    def ccw(A, B, C):
        return (C[1]-A[1]) * (B[0]-A[0]) > (B[1]-A[1]) * (C[0]-A[0])
    A = first_segment[0]
    B = first_segment[1]
    C = second_segment[0]
    D = second_segment[1]
    return ccw(A,C,D) != ccw(B,C,D) and ccw(A,B,C) != ccw(A,B,D)

def compute_orientation(first_segment, second_segment):
    #first segment is "undercrossed"
    def determinant(first_segment, second_segment):
        first_vector = (first_segment[1][0] - first_segment[0][0], first_segment[1][1] - first_segment[0][1])
        second_vector = (second_segment[1][0] - second_segment[0][0], second_segment[1][1] - second_segment[0][1])
        return first_vector[0] * second_vector[1] - first_vector[1] * second_vector[0] 
    return determinant(first_segment, second_segment)

def check_crossing(end_point, begin_point, strand):
    first_segment = (end_point, begin_point)
    for i in range(0, len(strand) - 1):
        second_segment = (strand[i], strand[i + 1])
        if is_intersection(first_segment, second_segment):
            res = compute_orientation(first_segment, second_segment)
            if res > 0:
                return 1
            else:
                return -1
    return 0


def find_crossed_strand(strand_index, strands, Wirt_dict):
    #TODO check empty
    first_index = strand_index
    second_index = (strand_index + 1) % len(strands)
    end_point = strands[first_index][-1]
    start_point = strands[second_index][0]
    iterable_strands = [i for i in range(len(strands)) if i not in {first_index, second_index} ]

    
    for st_id in iterable_strands:
        orientation = check_crossing(end_point, start_point, strands[st_id])
        if orientation < 0:
            Wirt_dict[first_index] = [-1, st_id]
            print(f"strands {first_index} and {second_index} undercross strand {st_id} - (negative crossing)")
            print(f"relation: x{st_id}**(-1) * x{second_index} * x{st_id} * x{first_index}**(-1)")
        if orientation > 0:
            Wirt_dict[first_index] = [1, st_id]
            print(f"strands {first_index} and {second_index} undercross strand {st_id} - (positive crossing)")
            print(f"relation: x{st_id} * x{second_index} * x{st_id}**(-1) * x{first_index}**(-1)")

